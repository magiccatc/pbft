# 项目模块功能文档

## 项目概述

本项目是一个**简化教学版 Fast-HotStuff** 共识算法实现，采用**固定主节点（节点0）**的方式演示 HotStuff 的核心阶段：Proposal、Prepare、PreCommit、Commit，并引入 Fast-HotStuff 的 **fast path**：主节点收集到 `2f+1` Prepare Vote 形成 Fast-QC，连续出现两个 Fast-QC 时提交父块。view-change 时主节点生成 **AggQC**（QC 列表 hash + 聚合签名）作为新视图证明。整体仍保留**简化 pacemaker + view-change** 与**最简批处理（mempool + batch）**机制。教学版在QC（Quorum Certificate）中引入**BLS聚合签名**：主节点聚合投票签名生成QC，副本验证QC签名与签名者集合。

**核心公式**: `n >= 3f + 1`，其中 n 为全网总节点数量，f 为最多允许的作恶、故障节点数量。系统阈值采用 `threshold = nodeCount*2/3 + 1`。

**当前配置**:
- 默认节点数量: `nodeCount = 9`（`main.go`）
- 门限值: `threshold = nodeCount*2/3 + 1`
- 主节点固定为: 节点 `0`
- 最大视图: `maxView = 10`
- 批大小: `batchSize = 2`
- 批超时: `batchTimeoutMs = 1500`
- slow path 等待窗口: `slowPathWaitMs = 200`
- 统计视图范围: `statsViewStart = 1`, `statsViewEnd = 9`

---

## 模块结构

### 1. 主程序模块 (`main.go`)

**功能描述**: 系统入口，负责节点地址初始化与启动模式选择。

**主要功能**:
- **节点配置管理**: 动态生成 `nodeTable`（节点ID -> 地址）
- **密钥生成**: 执行 `gen` 命令时调用 `genBlsKeys` 生成BLS密钥文件
- **程序启动**:
  - `程序名 gen <节点数量>`: 生成密钥
  - `程序名 <节点ID>`: 启动对应节点
  - `程序名 client`: 启动客户端

---

### 2. 客户端模块 (`client.go`)

**功能描述**: 发送请求并等待主节点回复，统计共识时延。

**关键特点**:
- 客户端**只向主节点发送 Request**
- 只需要收到 **1 个回复**（主节点）即可完成
- **并发发送20条请求**（不等待回复）
- 记录每条请求从**发送完成到收到回复**的时延

---

### 3. 共识核心模块 (`HotstuffProcess.go` + `HotstuffType.go`)

#### 3.1 数据结构

**区块与QC（教学版）**:
- `Block`: 包含 `ParentHash/Height/View/Proposer/CommandIDs/Justify`
- `QC`: 包含 `View/BlockHash/Phase/Signers/AggSig`
- `AggQC`: 包含 `View/Hash/QCs/Signers/AggSig`

**消息类型**:
- `Proposal`: 主节点提议的区块（携带完整请求列表，可选 `AggQC`）
- `Vote`: 副本对某阶段的投票（prepare/precommit/commit，携带 `Sig`）
- `PhaseMsg`: 主节点广播的阶段推进消息（携带QC）
- `AggQCRequest/AggQCVote`: leader 发起 AggQC hash 签名请求与副本签名返回
- `NewViewMsg`: 副本超时后向主节点发送的view-change消息（携带`HighQC`）

**核心状态**:
- `highQC`: 最高QC（用于生成新区块）
- `lockedQC`: 锁定QC（用于安全规则）
- `prepareVotes/precommitVotes/commitVotes`: 投票统计
- `fastQCBroadcasted/fastQCReady`: fast QC 广播与就绪状态
- `commitQCBroadcasted/commitReadyType`: commit QC 广播与提交就绪类型
- `slowPathReady`: slow path 等待窗口状态
- `aggQCRequests/aggQCVotes/aggQCs`: AggQC 请求、投票与生成结果
- `lastCommittedView/lastCommittedHash`: 串行化提交进度
- `lastProgress`: 最近一次进展时间（pacemaker使用）
- `newViewMessages`: 某个view收集到的NewView集合
- `proposedView`: 记录某个view是否已经提过案
- `requestPool`: 节点本地消息池（msgid -> Request）
- `pendingQueue`: 主节点待打包队列（msgid顺序）
- `blockRequests`: 区块哈希 -> 批次msgid列表
- `viewStart/viewDelay`: 主节点记录的 proposal→commit 时延

#### 3.2 安全规则（简化版）

当副本收到 Proposal 时，需要满足以下任一条件才投票：
- `block.Justify.View >= lockedQC.View`
- 或者 `block.ParentHash == lockedQC.BlockHash`

#### 3.3 QC 验证（BLS聚合签名）

QC 验证包括：
- `Phase` 与期望阶段一致
- `BlockHash` 匹配
- `Signers` 数量 >= `threshold`（fast QC 同样使用 `threshold`）
- `AggSig` 聚合签名与 `Signers` 的聚合公钥可验证

AggQC 验证包括：
- QC 列表 hash 一致
- `Signers` 数量 >= `threshold`
- `AggSig` 聚合签名与 `Signers` 的聚合公钥可验证

#### 3.4 简化 pacemaker/view-change

- 每个节点周期性检查**超时**（`viewTimeoutMs`）。
- 超时触发：节点**递增 view**，并向主节点发送 `NewViewMsg`。
- 主节点收集到 **threshold** 个 `NewViewMsg` 后：
  - 选择 `HighQC` 最高的QC作为新的 `highQC`
  - 生成 `AggQC`：对收集到的 QC 列表做 hash，请求副本签名并聚合
  - 在该 view 中**提议新区块**（可能为空命令，携带 `AggQC`）
- 当 `view` 达到 `maxView` 时，停止推进，不再触发新的 `NewView/Proposal`。

---

#### 3.5 最简批处理机制

- 客户端把请求发送给主节点，由 Proposal 携带完整请求给副本。
- 主节点把请求ID追加到 `pendingQueue`，当数量达到 `batchSize` 时触发提案。
- 若请求不足 `batchSize`，主节点在 `batchTimeoutMs` 超时后允许打包剩余请求。
- Proposal 同时携带 `CommandIDs` 与完整 `Requests`，副本验证二者一致后投票。

---

### 4. 网络通信模块 (`websocket.go`)

**功能描述**: 使用 WebSocket 进行节点间与客户端间通信。

**主要功能**:
- `wsListenWithReady`: 节点监听
- `clientWsListen`: 客户端监听
- `wsDial`: WebSocket 发送
- `jointMessage/splitMessage`: 命令头拼接/解析（前 12 字节为命令）

---

### 5. 工具模块 (`tool.go`)

**主要功能**:
- `GenerateRandomString`: 生成随机字符串
- `getDigest`: 对 Request 做 SHA256 摘要
- `computeBlockHash`: 计算区块哈希（不包含 `Hash/Justify` 字段）

---

### 6. BLS密钥模块 (`bls.go`)

**功能描述**: BLS密钥生成与加载，支持投票签名与QC聚合验签。

**说明**:
- `gen` 命令生成每个节点的 BLS 私钥/公钥文件
- QC 使用聚合签名，副本会进行验签

---

### 7. 门限RSA模块 (`trsa.go`)

**功能描述**: 保留的门限RSA密钥生成与签名逻辑（当前未使用）。

---

## 消息命名与命令常量

命令名称（前 12 字节）：
- `request` -> `Request`
- `proposal` -> `Proposal`
- `newView` -> `NewViewMsg`
- `votePrepare` -> `Vote`（Phase=prepare）
- `msgPreCommit` -> `PhaseMsg`（Phase=prepare QC）
- `votePreCom` -> `Vote`（Phase=precommit）
- `msgCommit` -> `PhaseMsg`（Phase=precommit QC）
- `voteCommit` -> `Vote`（Phase=commit）
- `msgFastQC` -> `PhaseMsg`（Phase=prepare Fast QC）
- `msgCommitQC` -> `PhaseMsg`（Phase=commit QC）
- `aggQCReq` -> `AggQCRequest`
- `aggQCVote` -> `AggQCVote`

注意：`votePreCommit` 的命令字符串为 `votePreCom`（长度限制导致截断）。

---

## 教学版共识流程（固定主节点）

1. **客户端发送 Request 给主节点**
2. **主节点批量打包请求并广播 Proposal**
   - `ParentHash = highQC.BlockHash`
   - `View` 由主节点递增
   - `CommandIDs` 为批次请求ID列表，`Requests` 携带完整请求
   - 附带 `Justify = highQC`
3. **副本验证 Proposal**：校验 `Requests` 与 `CommandIDs` 一致并写入消息池，然后发送 Prepare Vote
4. **主节点收集 Prepare Vote**：达到 `threshold` 后生成 Fast-QC 并广播 `msgFastQC`
5. **连续两个 Fast-QC**：提交父块（串行提交）
6. **slow path 等待窗口到期**：生成 Prepare QC 并广播 `msgPreCommit`
7. **副本验证 QC，更新 lockedQC，发送 PreCommit Vote**
8. **主节点收集 PreCommit Vote -> 生成 PreCommit QC -> 广播 msgCommit**
9. **副本验证 QC，更新 highQC，发送 Commit Vote**
10. **主节点收集 Commit Vote -> 生成 Commit QC -> 广播 msgCommitQC**
11. **副本标记已提交，主节点对批次内每条请求回复客户端**

---

## Pacemaker触发的view-change流程（简化）

1. **副本超时**：若在 `viewTimeoutMs` 内无进展，副本触发 `view++`
2. **发送 NewView**：携带本地 `HighQC` 给主节点
3. **主节点收集阈值NewView**：选择最高 `HighQC`
4. **主节点在新视图提案**：广播 Proposal（可能为空命令）
5. **后续阶段按正常流程继续**
6. **达到 `maxView` 后停止推进**：不再触发新的 NewView/Proposal

---

## 主节点共识时延统计

- 主节点在每个 view 首次 Proposal 时记录开始时间。
- 仅统计 `statsViewStart~statsViewEnd` 的 view。
- 当这些 view 达成 Commit 后，计算 `proposal -> commit` 时延并输出。
- 基于统计窗口计算吞吐量（请求数/耗时）。

---

## 客户端流程

- 只向主节点发送请求
- 并发发送 20 条请求（不等待回复）
- 收到 1 个回复即认为成功
- 统计每条请求**发送完成（主节点） -> 回复到达**的时延

---

## 注意事项

1. **view-change为简化版**：固定主节点，未做leader轮换
2. **QC 使用BLS聚合签名验证**：签名者集合达到阈值后才能生成QC
3. **fast path 门限**：Fast-QC 使用 `threshold`，`slowPathWaitMs` 控制 slow path 等待窗口
4. **AggQC 简化**：QC 列表做 hash，由副本签名并聚合
5. **批处理一致性**：Proposal 携带完整请求，副本校验与 `CommandIDs` 一致
6. **仅主节点回复客户端**：避免多副本重复回复
7. **区块哈希计算**：不包含 `Hash/Justify`，避免递归依赖
8. **串行提交**：仅在父块已提交时提交；fast path 需要连续两个 Fast-QC
9. **完全流水线**：主节点在 `highQC` 更新后可继续提案，不再限制未提交视图数量
10. **视图上限**：达到 `maxView` 后不再推进
11. **nodeCount/threshold**：需要与启动脚本一致
12. **共识统计**：主节点记录 `statsViewStart~statsViewEnd` 的 `proposal -> commit` 时延并计算吞吐量

---

## 文件结构

```
项目根目录/
├── main.go              # 主程序入口
├── client.go            # 客户端模块
├── HotstuffProcess.go   # 共识流程逻辑（教学版）
├── HotstuffType.go      # 消息/区块/QC定义
├── bls.go               # BLS密钥与签名工具
├── websocket.go         # WebSocket通信模块
├── tool.go              # 工具函数
├── trsa.go              # 门限RSA模块（教学版未使用）
├── go.mod               # Go模块定义
├── go.sum               # Go依赖锁定
├── README_启动说明.md   # 启动脚本使用说明
├── nodes.conf.example   # 节点数量配置示例
├── start_all.bat        # Windows启动脚本
├── start_all.sh         # Linux/Mac启动脚本
└── tKeys/               # 密钥存储目录
```

---

## 总结

当前版本面向教学与理解 Fast-HotStuff 的核心阶段推进机制，采用**固定主节点 + BLS聚合签名QC + 简化 pacemaker/view-change + 最简批处理**方式实现。它保留了 HotStuff 的 **Proposal/Prepare/PreCommit/Commit** 结构，并加入 fast path（连续两个 Fast-QC 提交父块）与 AggQC 的 view-change 证明逻辑。若需更接近标准 Fast-HotStuff，可进一步补充 leader 轮换、fast/slow 的严格证明与更完整的安全证明。
